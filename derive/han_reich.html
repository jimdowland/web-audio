<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Music for the Dérive — v1.5 (Speech Phase)</title>
  <style>
    body { margin: 0; overflow: hidden; background: #010103; color: white; font-family: "Times New Roman", serif; }
    canvas { position: fixed; top: 0; left: 0; z-index: -1; }
    .ui { position: relative; padding: 40px; max-width: 280px; background: rgba(0,0,0,0.85); backdrop-filter: blur(50px); height: 100vh; border-right: 1px solid rgba(255,255,255,0.03); display: flex; flex-direction: column; gap: 30px; }
    h2 { font-weight: 200; letter-spacing: -1px; margin: 0; opacity: 0.6; font-size: 1.2rem; }
    .row { display: flex; flex-direction: column; gap: 12px; }
    label { font-size: 8px; text-transform: uppercase; letter-spacing: 4px; opacity: 0.3; }
    input { width: 100%; accent-color: #6a2cdb; cursor: pointer; }
    button { width: 100%; padding: 18px; background: white; color: black; border: none; border-radius: 2px; cursor: pointer; font-weight: 800; font-size: 11px; letter-spacing: 2px; }
    button#stop { background: transparent; color: white; border: 1px solid rgba(255,255,255,0.1); margin-top: 10px; }
    button:disabled { opacity: 0.05; }
    select { width: 100%; padding: 14px; background: #000; color: white; border: 1px solid #222; border-radius: 2px; font-size: 11px; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div class="ui">
    <h2>Soma & Mist</h2>
    <div class="row"><label>Presence</label><input id="vol" type="range" min="0" max="1.5" step="0.01" value="0.8"></div>
    <div class="row"><label>Drift</label><input id="move" type="range" min="0" max="1" step="0.01" value="0.5"></div>
    <div class="row"><label>Pressure</label><input id="press" type="range" min="0" max="1" step="0.01" value="0.15"></div>
    <div class="row">
      <label>Scale</label>
      <select id="scale">
        <option value="dorian">Dorian</option>
        <option value="aeolian">Aeolian</option>
        <option value="penta">Pentatonic</option>
      </select>
    </div>
    <div style="margin-top: auto;">
      <button id="start">BEGIN</button>
      <button id="stop" disabled>END</button>
    </div>
  </div>

<script>
(() => {
  const lerp = (a, b, t) => a + (b - a) * t;
  const rnd = (a, b) => a + Math.random() * (b - a);
  const midiToHz = (m) => 440 * Math.pow(2, (m - 69) / 12);
  const $ = (id) => document.getElementById(id);
  const canvas = $("canvas"), cv = canvas.getContext("2d");
  let w, h;
  const resize = () => { w = canvas.width = window.innerWidth; h = canvas.height = window.innerHeight; };
  window.onresize = resize; resize();

  const HAN_WORDS = ["breath", "bone", "white", "ash", "petal", "vein", "snow", "salt", "tongue", "root", "leaf", "skin", "cold", "light"];
  
  class EMA { constructor(a) { this.a = a; this.v = 0.5; } step(x) { this.v = lerp(this.v, x, this.a); return this.v; } }
  const smMove = new EMA(0.01), smPress = new EMA(0.01), smVol = new EMA(0.05);
  const SCALES = { dorian: [0, 2, 3, 5, 7, 9, 10], aeolian: [0, 2, 3, 5, 7, 8, 10], penta: [0, 3, 5, 7, 10] };

  let ctx = null, masterGain, limiter, spaceBus, highShelf;
  let updateTimer = null;
  const cells = new Array(8);
  let fields = [], dust = [], words = [];

  // --- REICH SPEECH ENGINE ---
  function speakReich(word) {
    if (!window.speechSynthesis) return;
    const synth = window.speechSynthesis;
    // Create two utterances
    const vA = new SpeechSynthesisUtterance(word);
    const vB = new SpeechSynthesisUtterance(word);
    
    [vA, vB].forEach((v, i) => {
      v.pitch = 0.1; // Deep, gravelly
      v.volume = 0.2; // Subtle
      // The Reich Drift: slightly different rates
      v.rate = i === 0 ? 0.6 : 0.58; 
      
      // Slight delay to start the "interference" pattern
      setTimeout(() => synth.speak(v), i * 200);
    });
  }

  function spawnWord() {
    const wordText = HAN_WORDS[Math.floor(Math.random() * HAN_WORDS.length)];
    words.push({
        text: wordText,
        x: rnd(w * 0.3, w * 0.7), y: h * 0.6, a: 0, ta: rnd(0.3, 0.5), life: 1, dec: rnd(0.001, 0.002)
    });
    speakReich(wordText); // Voice follows visual
  }

  function createField(kind, pr) {
    if (kind === 'celestial') {
      fields.push({ x: w/2, y: h*0.1, w: w*0.7, h: 2, a: 0, ta: 0.1, c: [180, 200, 255], life: 1, dec: 0.0006 });
      spawnWord();
    } else if (kind === 'deep') {
      fields.push({ x: w/2, y: h*0.9, w: w, h: h*0.4, a: 0, ta: 0.12, c: [5, 2, 10], life: 1, dec: 0.001 });
    } else {
      const isReed = pr > 0.5;
      fields.push({
        x: rnd(w*0.1, w*0.9), y: rnd(h*0.1, h*0.9),
        w: isReed ? rnd(60, 120) : rnd(200, 500), h: isReed ? rnd(10, 25) : rnd(100, 350),
        a: 0, ta: isReed ? 0.25 : 0.1, c: isReed ? [80, 30, 140] : [25, 15, 60],
        life: 1, dec: rnd(0.002, 0.005)
      });
    }
  }

  function draw() {
    cv.globalCompositeOperation = "source-over";
    cv.filter = 'none';
    cv.fillStyle = `rgba(1, 1, 3, ${lerp(0.1, 0.25, smPress.v)})`;
    cv.fillRect(0, 0, w, h);

    cv.filter = 'blur(35px)';
    fields.forEach((p, i) => {
      p.a = lerp(p.a, p.ta * p.life, 0.02);
      cv.fillStyle = `rgba(${p.c[0]}, ${p.c[1]}, ${p.c[2]}, ${p.a})`;
      cv.fillRect(p.x - p.w/2, p.y - p.h/2, p.w, p.h);
      p.y += (smMove.v - 0.5) * 0.4;
      p.life -= p.dec;
      if (p.life <= 0) fields.splice(i, 1);
    });

    cv.filter = 'none';
    cv.fillStyle = `rgba(255, 255, 255, ${lerp(0.1, 0.3, smMove.v)})`;
    dust.forEach(d => {
        d.x += d.vx + (smMove.v - 0.5) * 0.3; d.y += d.vy;
        if(d.x < 0) d.x = w; if(d.x > w) d.x = 0;
        if(d.y < 0) d.y = h; if(d.y > h) d.y = 0;
        cv.fillRect(d.x, d.y, d.s, d.s);
    });

    cv.font = "italic 16px Times New Roman";
    cv.textAlign = "center";
    words.forEach((wrd, i) => {
        wrd.a = lerp(wrd.a, wrd.ta * wrd.life, 0.03);
        cv.fillStyle = `rgba(255, 255, 255, ${wrd.a})`;
        cv.fillText(wrd.text, wrd.x, wrd.y);
        wrd.y -= 0.25; wrd.life -= wrd.dec;
        if(wrd.life <= 0) words.splice(i, 1);
    });
    requestAnimationFrame(draw);
  }
  draw();

  function playSomaVoice({freq, time, amp, decay, bright, pr}) {
    const osc = ctx.createOscillator();
    const filter = ctx.createBiquadFilter();
    const env = ctx.createGain();
    osc.type = "sine";
    osc.frequency.setValueAtTime(freq, time);
    env.gain.setValueAtTime(0, time);
    env.gain.linearRampToValueAtTime(amp, time + 0.02);
    env.gain.exponentialRampToValueAtTime(0.0001, time + decay);
    filter.type = "highpass"; filter.frequency.setValueAtTime(150, time);
    osc.connect(filter); filter.connect(env); env.connect(highShelf); env.connect(limiter);
    osc.start(time); osc.stop(time + decay + 0.5);
    createField('cell', pr);
  }

  function playCelestial(time) {
    const osc = ctx.createOscillator();
    const vca = ctx.createGain();
    osc.frequency.setValueAtTime(midiToHz(84 + SCALES[$("scale").value][0]), time);
    osc.type = "sine";
    const dur = rnd(12, 18);
    vca.gain.setValueAtTime(0, time);
    vca.gain.linearRampToValueAtTime(0.006, time + dur/2);
    vca.gain.linearRampToValueAtTime(0, time + dur);
    osc.connect(vca); vca.connect(spaceBus);
    osc.start(time); osc.stop(time + dur);
    createField('celestial');
  }

  function playDeep(time) {
    const osc = ctx.createOscillator();
    const vca = ctx.createGain();
    osc.frequency.setValueAtTime(midiToHz(21 + SCALES[$("scale").value][0]), time);
    osc.type = "sine";
    vca.gain.setValueAtTime(0, time);
    vca.gain.linearRampToValueAtTime(0.04, time + 4);
    vca.gain.linearRampToValueAtTime(0, time + 15);
    osc.connect(vca); vca.connect(masterGain);
    osc.start(time); osc.stop(time + 15);
    createField('deep');
  }

  class Cell {
    constructor(id) { this.id = id; }
    schedule(now) {
      const pr = smPress.v;
      const scale = SCALES[$("scale").value];
      const midi = 48 + scale[Math.floor(Math.random()*scale.length)];
      playSomaVoice({ freq: midiToHz(midi), time: now + 0.1, amp: lerp(0.35, 0.15, pr), decay: lerp(5, 2, pr), bright: smMove.v, pr });
    }
  }

  function update() {
    if(!ctx) return;
    smMove.step(+$("move").value); smPress.step(+$("press").value); smVol.step(+$("vol").value);
    masterGain.gain.setTargetAtTime(smVol.v, ctx.currentTime, 0.1);
    for (let i = 0; i < 6; i++) {
      if (!cells[i]) cells[i] = new Cell(i);
      if (Math.random() > 0.96) cells[i].schedule(ctx.currentTime);
    }
    if (Math.random() > 0.995) playCelestial(ctx.currentTime);
    if (Math.random() > 0.998) playDeep(ctx.currentTime);
  }

  $("start").onclick = async () => {
    ctx = new AudioContext();
    limiter = ctx.createDynamicsCompressor();
    limiter.threshold.setValueAtTime(-12, ctx.currentTime);
    highShelf = ctx.createBiquadFilter();
    highShelf.type = "highshelf";
    highShelf.frequency.setValueAtTime(3000, ctx.currentTime);
    highShelf.gain.setValueAtTime(6, ctx.currentTime);
    masterGain = ctx.createGain(); masterGain.gain.value = 0;
    spaceBus = ctx.createGain(); spaceBus.gain.value = 0.4;
    const delay = ctx.createDelay(); delay.delayTime.value = 0.6;
    const fb = ctx.createGain(); fb.gain.value = 0.35;
    highShelf.connect(spaceBus); spaceBus.connect(delay); delay.connect(fb); fb.connect(delay);
    limiter.connect(masterGain); delay.connect(masterGain);
    masterGain.connect(ctx.destination);
    await ctx.resume();
    // Warm up voices
    const silence = new SpeechSynthesisUtterance("");
    window.speechSynthesis.speak(silence);
    $("start").disabled = true; $("stop").disabled = false;
    updateTimer = setInterval(update, 250);
  };

  $("stop").onclick = () => {
    masterGain.gain.setTargetAtTime(0, ctx.currentTime, 3);
    window.speechSynthesis.cancel();
    setTimeout(() => { clearInterval(updateTimer); location.reload(); }, 3200);
  };
})();
</script>
</body>
</html>